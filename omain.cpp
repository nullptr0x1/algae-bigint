#ifndef ALGAE_VINTEGER_H
#define ALGAE_VINTEGER_H
#include <compare>
#include <cstdint>
#include <string>
#include <string_view>
#include <utility>
#include <cmath>
#include <iostream>
namespace algae {class vinteger {friend class intermediate_state_integer;using __computing_unit_type = std::uint_fast64_t;using __CUtype = __computing_unit_type;using __HCUtype = std::uint_fast32_t;constexpr static std::size_t __CUtype_bit_length = sizeof(std::uint64_t) * 8;constexpr static std::size_t __HCUtype_bit_length = sizeof(std::uint32_t ) * 8;__CUtype * __buffer = nullptr;std::int32_t __bit_length = 0;std::uint32_t __capacity = 0;void __change_capacity(std::uint32_t new_capacity, bool keep_value = false, bool initial = false);void __try_reserve(std::size_t unit_count);void __capacity_adaptive();void __initialization_by_cinteger(std::int64_t x);void __initialization_by_cinteger(std::uint64_t x);public:using CUtype = __CUtype;vinteger() = default;template<std::integral T>vinteger(T x) { if(std::is_signed_v<T>)__initialization_by_cinteger((std::int64_t)x); else __initialization_by_cinteger((std::uint64_t)x); }template<std::floating_point T>vinteger(T x) { __initialization_by_cinteger((std::int64_t)std::floor(x)); }vinteger(std::string_view source);vinteger(const vinteger& source);vinteger(vinteger&& source);template<std::unsigned_integral T>vinteger& operator=(const T x){if(x == 0)clear();else __change_capacity(1), __bit_length = std::bit_width(x);return *this;}template<std::signed_integral T>vinteger& operator=(const T x){this->operator=((std::make_unsigned<T>)std::abs(x));__bit_length = __set_int_sign(__bit_length, x < 0 ? -1 : 1);return *this;}vinteger& operator=(const vinteger& source);vinteger& operator=(vinteger&& source);~vinteger();int sign() const; bool empty() const;std::size_t value_bit_width() const;private:std::size_t __value_length() const;std::size_t __HCU_value_length() const;public:void clear();friend std::strong_ordering operator <=>(const vinteger&, const vinteger&);private:std::strong_ordering __compare_template(const vinteger& a, const std::int64_t b);std::strong_ordering __compare_template(const vinteger& a, const std::uint64_t b);public:template<std::integral T>friend std::strong_ordering operator <=>(const vinteger&, const T);template<std::integral T>friend std::strong_ordering operator <=>(const T, const vinteger&);template<std::floating_point T>friend std::strong_ordering operator <=>(const vinteger&, const T);template<std::floating_point T>friend std::strong_ordering operator <=>(const T, const vinteger&);vinteger& operator <<=(const std::size_t shift);vinteger operator<<(const std::size_t shift) const;vinteger& operator >>=(const std::size_t shift);vinteger operator>>(const std::size_t shift) const;private:friend struct adder_context;public:vinteger operator-() const;friend vinteger operator+(const vinteger&, const vinteger&);friend vinteger operator-(const vinteger&, const vinteger&);template<std::integral T>friend vinteger operator+(const vinteger&, const T);template<std::integral T>friend vinteger operator-(const vinteger&, const T);template<std::integral T>friend vinteger operator+(const T, const vinteger&);template<std::integral T>friend vinteger operator-(const T, const vinteger&);vinteger& operator+=(const vinteger& b);vinteger& operator-=(const vinteger& b);template<std::integral T>vinteger& operator+=(const T x) {return operator+=(vinteger(x));}template<std::integral T>vinteger& operator-=(const T x) {return operator-=(vinteger(x));}template<std::floating_point T>vinteger& operator+=(const T x) {return operator+=(vinteger(x));}template<std::floating_point T>vinteger& operator-=(const T x) {return operator-=(vinteger(x));}private:friend struct multiplier_context;public:friend vinteger operator*(const vinteger&, const vinteger&);template<std::integral T>friend vinteger operator*(const vinteger&, const T);template<std::integral T>friend vinteger operator*(const T, const vinteger&);vinteger& operator*=(const vinteger& other);template<std::integral T>vinteger operator*=(const T x) {return (*this *= vinteger(x));}private:friend struct divider_context;public:friend vinteger operator/(const vinteger&, const vinteger&);friend vinteger operator%(const vinteger&, const vinteger&);template<std::integral T>friend vinteger operator/(const vinteger&, const T);template<std::integral T>friend vinteger operator/(const T, const vinteger&);template<std::integral T>friend vinteger operator%(const vinteger&, const T);template<std::integral T>friend vinteger operator%(const T, const vinteger&);vinteger& operator/=(const vinteger& other);vinteger& operator%=(const vinteger& other);template<std::integral T>vinteger operator/=(const T x) {return (*this /= vinteger(x));}template<std::integral T>vinteger operator%=(const T x) {return (*this %= vinteger(x));}std::string to_string() const;operator std::string() const;};std::strong_ordering operator <=>(const vinteger& a, const vinteger& b);template<std::integral T>std::strong_ordering operator <=>(const vinteger& a, const T b) {return vinteger::__compare_template(a, b);}template<std::integral T>std::strong_ordering operator <=>(const T b, const vinteger& a) {auto r = vinteger::__compare_template(a, b);if(r == std::strong_ordering::less)return std::strong_ordering::greater;if(r == std::strong_ordering::greater)return std::strong_ordering::less;return std::strong_ordering::equal;}template<std::floating_point T>std::strong_ordering operator <=>(const vinteger& a, const T b) {return a <=> (std::int64_t)std::ceil(b);}template<std::floating_point T>std::strong_ordering operator <=>(const T a, const vinteger& b) {return (std::int64_t)std::ceil(a) <=> b;}vinteger operator+(const vinteger& a, const vinteger& b);vinteger operator-(const vinteger& a, const vinteger& b);template<std::integral T>vinteger operator+(const vinteger& a, const T b) {return a + vinteger(b);}template<std::integral T>vinteger operator-(const vinteger& a, const T b) {return a - vinteger(b);}template<std::integral T>vinteger operator+(const T a, const vinteger& b) {return vinteger(a) + b;}template<std::integral T>vinteger operator-(const T a, const vinteger& b) {return vinteger(a) - b;}vinteger operator*(const vinteger& a, const vinteger& b);template<std::integral T>vinteger operator*(const vinteger& a, const T b) {return a * vinteger(b);}template<std::integral T>vinteger operator*(const T a, const vinteger& b) {return vinteger(a) * b;}template<std::integral T>vinteger operator/(const vinteger& a, const T b) {return a / vinteger(b);}template<std::integral T>vinteger operator/(const T a, const vinteger& b) {return vinteger(a) / b;}template<std::integral T>vinteger operator%(const vinteger& a, const T b) {return a % vinteger(b);}template<std::integral T>vinteger operator%(const T a, const vinteger& b) {return vinteger(a) % b;}std::istream& operator >> (std::istream& in, vinteger& arg);std::ostream& operator << (std::ostream& out, const vinteger& arg);namespace vinteger_literals {vinteger operator ""_vi(const char* x);}}
#endif
namespace algae {extern std::int64_t __set_int_sign(const std::uint64_t x, int sign);extern std::size_t bit_capacity(const std::size_t bit_count, const std::size_t unit_size);extern vinteger::CUtype full_adder(vinteger::CUtype a, vinteger::CUtype b, bool& carry);extern vinteger::CUtype carry_handle(vinteger::CUtype x, bool& carry);struct multiplier_context {using __CUtype = vinteger::__CUtype;constexpr static std::size_t __CUtype_bit_length = vinteger::__CUtype_bit_length;const vinteger * vint_max = nullptr;const vinteger * vint_min = nullptr;vinteger * output = nullptr;int sign = 0;bool pretreatment(const vinteger& x, const vinteger& y, vinteger& z) {if(x.empty() || y.empty())z.clear();else if(x.value_bit_width() == 1)z = x.sign() == y.sign() ? y : -y;else if(y.value_bit_width() == 1)z = x.sign() == y.sign() ? x : -x;else if(x.value_bit_width() > 32 || y.value_bit_width() > 32)return false;else {z.__change_capacity(1);z.__buffer[0] = x.__buffer[0] * y.__buffer[0];z.__bit_length = __set_int_sign(std::bit_width(z.__buffer[0]), x.sign() * y.sign());}return true;}multiplier_context(const vinteger& x, const vinteger& y, vinteger& z){if(pretreatment(x, y, z))return;sign = x.sign() * y.sign();output = &z;if (x >= y)vint_max = &x, vint_min = &y;else vint_max = &y, vint_min = &x;naive_multiplication();}inline bool bitget(const __CUtype* buffer, const int i) const {return buffer[i / __CUtype_bit_length] & (1ull << __CUtype(i % __CUtype_bit_length));}std::size_t shift_plus(const int shift) {const std::size_t length = vint_max->__value_length();const std::size_t shift_unit = shift / __CUtype_bit_length;const std::size_t shift_bit = shift % __CUtype_bit_length;__CUtype overflow = 0, index = 0;bool carry = false;for(; index < length; ++index){const __CUtype temporary = vint_max->__buffer[index], shift_index = index + shift_unit;output->__buffer[shift_index] = full_adder(output->__buffer[shift_index], overflow | (temporary << shift_bit), carry);overflow = temporary >> (__CUtype_bit_length - shift_bit);}if(overflow){output->__buffer[index + shift_unit] = full_adder(output->__buffer[index + shift_unit], overflow, carry);++index;}for(; carry; ++index){const __CUtype shift_index = index + shift_unit;output->__buffer[shift_index] = carry_handle(output->__buffer[shift_index], carry);}return index + shift_unit - 1;}void naive_multiplication(){std::size_t highest_order = 0;for(int i = vint_min->value_bit_width() - 1; i >= 0; --i){if(!bitget(vint_min->__buffer, i))continue;if(output->__capacity == 0)output->__change_capacity(bit_capacity(vint_min->value_bit_width() + vint_max->value_bit_width(), __CUtype_bit_length) + 1, false, true);highest_order = std::max(highest_order, shift_plus(i));}output->__bit_length = __set_int_sign(std::bit_width(output->__buffer[highest_order]) + highest_order * __CUtype_bit_length, sign);}};vinteger& vinteger::operator*=(const vinteger& other) {*this = *this * other;return *this;}vinteger operator*(const vinteger& a, const vinteger& b) {vinteger c;multiplier_context(a, b, c);return c;}}
#include <cstring>
namespace algae {void vinteger::__change_capacity(std::uint32_t new_capacity, bool keep_value, bool initial){if(new_capacity == 0)return clear();__CUtype * new_buffer = new __CUtype[new_capacity];if(initial)std::memset(new_buffer, 0, new_capacity * sizeof(__CUtype));if(__buffer){if(keep_value)std::memcpy(new_buffer, __buffer, __capacity * sizeof(__CUtype));delete[] __buffer;}__buffer = new_buffer;__capacity = new_capacity;}void vinteger::__try_reserve(std::size_t unit_count){if(unit_count > __capacity)__change_capacity(unit_count, true);else if(__value_length() == 0)clear();}void vinteger::__capacity_adaptive() {if(__capacity > __value_length())__change_capacity(__value_length());}void vinteger::__initialization_by_cinteger(std::int64_t x){if(x == 0)return;__change_capacity(1);__buffer[0] = (std::uintmax_t)std::abs(x);__bit_length = std::bit_width(__buffer[0]) * (x < 0 ? -1 : 1);}void vinteger::__initialization_by_cinteger(std::uint64_t x){__change_capacity(1);__buffer[0] = x;__bit_length = std::bit_width(__buffer[0]);}vinteger::vinteger(const vinteger& source) { operator =(source);}vinteger::vinteger(vinteger&& source) {operator =(std::move(source));}vinteger& vinteger::operator=(const vinteger& source){if(this == &source)return *this;__change_capacity(source.__value_length());std::memcpy(__buffer, source.__buffer, source.__value_length() * sizeof(__CUtype));__bit_length = source.__bit_length;return *this;}vinteger& vinteger::operator=(vinteger&& source){if(this == &source)return *this;if(__buffer)delete[] __buffer;__buffer = std::exchange(source.__buffer, nullptr);__bit_length = std::exchange(source.__bit_length, 0);__capacity = std::exchange(source.__capacity, 0);return *this;}vinteger::~vinteger() {clear();}bool vinteger::empty() const {return __bit_length == 0;}int vinteger::sign() const {if(__bit_length == 0)return 0;return __bit_length > 0 ? 1 : -1;}std::size_t vinteger::value_bit_width() const {return std::abs(__bit_length);}inline std::size_t bit_capacity(const std::size_t bit_count, const std::size_t unit_size) {return bit_count / unit_size + bool(bit_count % unit_size);}std::size_t vinteger::__value_length() const {return bit_capacity(std::abs(__bit_length), __CUtype_bit_length);}std::size_t vinteger::__HCU_value_length() const {return bit_capacity(std::abs(__bit_length), __HCUtype_bit_length);}void vinteger::clear(){if(__buffer)delete[] __buffer;__buffer = nullptr;__bit_length = 0;__capacity = 0;}}
namespace algae {extern std::int64_t __set_int_sign(const std::uint64_t x, int sign);vinteger& vinteger::operator <<=(const std::size_t shift){if(shift == 0 || empty())return *this;const std::size_t length = __value_length();const std::size_t shift_unit = shift / __CUtype_bit_length;const std::size_t shift_bit = shift % __CUtype_bit_length;std::uint64_t overflow = 0;__bit_length += __set_int_sign(shift, sign());__try_reserve(__value_length());if(std::size_t i = 0; shift_bit){while(__buffer[i] == 0){   if((++i) >= length)break;}for(;i < length; ++i){const std::uint64_t temp = __buffer[i];__buffer[i] = overflow | (temp << shift_bit);overflow = temp >> (__CUtype_bit_length - shift_bit);}}if(shift_unit){std::memmove(__buffer + shift_unit, __buffer, length * sizeof(__CUtype));std::memset(__buffer, 0, shift_unit * sizeof(__CUtype));}if(overflow)__buffer[__value_length() - 1] = overflow;return *this;}vinteger vinteger::operator<<(const std::size_t shift) const {vinteger result(*this);result <<= shift;return result;}vinteger& vinteger::operator >>=(const std::size_t shift){if(shift == 0 || empty())return *this;const std::size_t length = __value_length();const std::size_t shift_unit = shift / __CUtype_bit_length;const std::size_t shift_bit = shift % __CUtype_bit_length;if(std::uint64_t underflow = 0; shift_bit){int stop = 0;while(__buffer[stop] == 0){   if((++stop) >= (int)length)break;}for(int i = length - 1; i >= stop; --i){const std::uint64_t temp = __buffer[i];__buffer[i] = underflow | (temp >> shift_bit);underflow = temp << (__CUtype_bit_length - shift_bit);}if(stop && underflow)__buffer[stop - 1] = underflow;}if(shift_unit)std::memmove(__buffer, __buffer + shift_unit, length * sizeof(__CUtype));__bit_length -= __set_int_sign(shift, sign());__try_reserve(__value_length());return *this;}vinteger vinteger::operator>>(const std::size_t shift) const {vinteger result(*this);result >>= shift;return result;}}
#include <stdexcept>
namespace algae {extern std::int64_t __set_int_sign(const std::uint64_t x, int sign);struct divider_context {using __CUtype = vinteger::__CUtype;constexpr static std::size_t __CUtype_bit_length = vinteger::__CUtype_bit_length;const vinteger *divisor = nullptr;const vinteger *dividend = nullptr;vinteger *merchant = nullptr, *remainder = nullptr;int sign = 0;bool pretreatment(const vinteger& x, const vinteger& y) {if(x.empty()){if (merchant)merchant->clear();if (remainder)remainder->clear();}else if(y.empty())throw std::runtime_error("divisor is zero");else if(y.value_bit_width() == 1){if (merchant)*merchant = x.sign() == y.sign() ? x : -x;if (remainder)remainder->clear();}else if(x.value_bit_width() > 64 || y.value_bit_width() > 64)return false;else {if (merchant){merchant->__change_capacity(1);merchant->__buffer[0] = x.__buffer[0] / y.__buffer[0];merchant->__bit_length = __set_int_sign(std::bit_width(merchant->__buffer[0]), sign);}if (remainder){remainder->__change_capacity(1);remainder->__buffer[0] = x.__buffer[0] % y.__buffer[0];remainder->__bit_length = __set_int_sign(std::bit_width(remainder->__buffer[0]), sign);}}return true;}void naive_division(){if (this->divisor->value_bit_width() < this->dividend->value_bit_width()){if (remainder)*remainder = *this->divisor;return;}vinteger divisor = *(this->divisor);vinteger dividend = *(this->dividend) << (this->divisor->value_bit_width() - this->dividend->value_bit_width());for(int shift = this->divisor->value_bit_width() - this->dividend->value_bit_width(); shift >= 0; ){if(divisor < dividend){shift--, dividend >>= 1;continue;}divisor -= dividend;if (merchant == nullptr)continue;if(merchant->__capacity == 0)merchant->__change_capacity(std::max(std::size_t(shift / __CUtype_bit_length + bool(shift % __CUtype_bit_length)), std::size_t(1)), false, true);merchant->__buffer[shift / __CUtype_bit_length] |= 1ull << shift % __CUtype_bit_length;}if (merchant)if(merchant->__capacity != 0){auto bit_length = std::bit_width(merchant->__buffer[merchant->__capacity - 1]) + __CUtype_bit_length * (merchant->__capacity - 1);merchant->__bit_length = __set_int_sign(bit_length, sign);}if (remainder)*remainder = std::move(divisor);}divider_context(const vinteger& x, const vinteger& y, vinteger* z = nullptr, vinteger* w = nullptr):divisor(&x), dividend(&y), merchant(z), remainder(w), sign(x.sign() * y.sign()){if(pretreatment(x, y))return;naive_division();}};vinteger operator/(const vinteger& a, const vinteger& b) {vinteger merchant;divider_context context(a, b, &merchant);return merchant;}vinteger operator%(const vinteger& a, const vinteger& b){vinteger remainder;divider_context context(a, b, nullptr, &remainder);return remainder;}vinteger& vinteger::operator/=(const vinteger& other){*this = *this / other;return *this;}vinteger& vinteger::operator%=(const vinteger& other){*this = *this % other;return *this;}}
#include <algorithm>
#include <vector>
#include <limits>
namespace algae {class cast_standard {private:static constexpr std::uint64_t init_overflow_bound(){std::uint64_t l = 1;for(int i = 0; i < std::numeric_limits<std::uint64_t>::digits10; ++i)l *= 10;return l;}public:static std::uint64_t overflow_bound;static std::uint64_t half_overflow_bound;std::vector<std::uint64_t> buffer;std::size_t count = 64;cast_standard() : buffer({std::numeric_limits<std::uint64_t>::max() % overflow_bound + 1,std::numeric_limits<std::uint64_t>::max() / overflow_bound}){}std::size_t length() const {return buffer.size();}std::size_t binary_length() const {return bit_width() / 64 + bool(bit_width() % 64);}std::size_t bit_width() const {return count + 1;}std::size_t power_of_2() const {return count;}void mul2(){bool carry = false;for(auto& i : buffer){bool carry_out = i >= half_overflow_bound;i = (carry_out ? (i - half_overflow_bound) : i) * 2 + carry;carry = carry_out;}if(carry)buffer.push_back(carry);++count;}void div2(){bool retreat = false;std::for_each(buffer.rbegin(), buffer.rend(), [&](std::uint64_t& i) {bool retreat_out = i & 1;i = retreat ? (i / 2) + half_overflow_bound : i / 2;retreat = retreat_out;});while(buffer.back() == 0)buffer.pop_back();--count;}};class intermediate_state_integer {public:std::uint64_t * buffer = nullptr;std::uint32_t length = 0;bool sign = false;private:static std::uint64_t * make_int64_memory(const std::size_t n) {auto memory = new std::uint64_t[n];std::memset(memory, 0, n * sizeof(std::uint64_t));return memory;}inline bool bitget(const std::uint8_t * memory, std::size_t index) {return memory[index / 8] & (1 << (index % 8));}inline static std::uint64_t add_with_carry(std::uint64_t a, std::uint64_t b, bool& carry) {a += carry;carry = a >= cast_standard::overflow_bound - b;return carry ? a - (cast_standard::overflow_bound - b) : a + b;}public:intermediate_state_integer(const vinteger& source){buffer = make_int64_memory(std::max(std::size_t((source.__value_length() * 64 * 0.3010) / 8 + 1), std::size_t(2)));sign = source.__bit_length < 0;buffer[0] = source.__buffer[0] % cast_standard::overflow_bound;buffer[1] = source.__buffer[0] / cast_standard::overflow_bound;length = buffer[1] != 0 ? 2 : 1;for(cast_standard standard; standard.power_of_2() < source.value_bit_width(); standard.mul2()){bool carry = false;if(bitget((const std::uint8_t*)source.__buffer, standard.power_of_2())){for(std::size_t i = 0; i < standard.length(); ++i)buffer[i] = add_with_carry(buffer[i], standard.buffer[i], carry);buffer[standard.length()] += carry;length = std::max((std::uint32_t)standard.length() + carry, length);}}}std::string convert_to_string(){std::string result;result.reserve(length * 19 + sign);bool prefix_zeros = true;if(sign)result += '-';for(std::int64_t i = length - 1; i >= 0; --i){for(std::uint64_t c = buffer[i], shift = cast_standard::overflow_bound / 10; shift >= 1; shift /= 10){std::uint8_t r = c / shift;if(r == 0 && prefix_zeros)continue;prefix_zeros = false;result += r + '0';c %= shift;}}return result;}};std::uint64_t cast_standard::overflow_bound = cast_standard::init_overflow_bound();std::uint64_t cast_standard::half_overflow_bound = cast_standard::overflow_bound / 2;std::string vinteger::to_string() const {if(empty())return "0";return intermediate_state_integer(*this).convert_to_string();}vinteger::operator std::string() const {return to_string();}extern std::int64_t __set_int_sign(const std::uint64_t x, int sign);int __legitimacy_testing(std::string_view source){if(source.empty())throw std::invalid_argument("source is empty");int sign = source[0] == '-' ? -1 : 1;if(!(source[0] == '-' || source[0] == '+' || std::isdigit(source[0])))throw std::invalid_argument("source is not a valid integer");for(size_t i = 1; i < source.size(); i++)if(!std::isdigit(source[i]))throw std::invalid_argument("source is not a valid integer");return sign;}std::string_view __remove_prefix_zeros(std::string_view source){for(std::size_t i = std::isdigit(source.front()) ? 0 : 1; i < source.size(); ++i){if(source[i] != '0')return source.substr(i);}return "";}vinteger::vinteger(std::string_view source){
#if 1
int sign = __legitimacy_testing(source);std::string_view copy = __remove_prefix_zeros(source);if(copy.empty())return;__HCUtype temporary = 0, shift = 1;constexpr static __HCUtype overflow_bound = 1000000000;auto it = copy.begin();for(;it != copy.end() && shift < overflow_bound; ++it){if(shift != 1)temporary *= 10;temporary += (*it - '0');shift *= 10;}*this += temporary;temporary = 0, shift = 1;for(; it != copy.end(); ++it){if(shift == overflow_bound){*this *= overflow_bound;*this += temporary;temporary = 0, shift = 1;}if(shift != 1)temporary *= 10;temporary += (*it - '0');shift *= 10;}*this *= shift;*this += temporary;__bit_length = __set_int_sign(__bit_length, sign);
#else
int sign = __legitimacy_testing(source);std::string_view copy = __remove_prefix_zeros(source);if(copy.empty())return;*this += (copy.front() - '0');for(auto it = copy.begin() + 1; it != copy.end(); ++it){*this *= 10;*this += (*it - '0');}__bit_length = __set_int_sign(__bit_length, sign);
#endif
}std::istream& operator >> (std::istream& in, vinteger& arg){std::string s;in >> s;arg = vinteger(s);return in;}std::ostream& operator << (std::ostream& out, const vinteger& arg){out << arg.to_string();return out;}namespace vinteger_literals {vinteger operator ""_vi(const char* x) {return vinteger(x);}}}
namespace algae {inline int __int_sign(const std::int64_t x) {if(x > 0)return 1;return x ? -1 : 0;}inline int __int_sign(const std::uint64_t x) {return x ? 1 : 0;}inline std::int64_t __set_int_sign(const std::uint64_t x, int sign) {return sign > 0 ? x : -((std::int64_t)x);}std::strong_ordering vinteger::__compare_template(const vinteger& a, const std::int64_t b){if(auto r = a.sign() <=> __int_sign(b) ; r != std::strong_ordering::equal || (a.empty() && b == 0))return r;if(a.value_bit_width() >= __CUtype_bit_length - 1)return std::strong_ordering::greater;return __set_int_sign(a.__buffer[0], a.sign()) <=> b;}std::strong_ordering vinteger::__compare_template(const vinteger& a, const std::uint64_t b){if(auto r = a.sign() <=> __int_sign(b); r != std::strong_ordering::equal || (a.empty() && b == 0)) return r;if(a.value_bit_width() >= __CUtype_bit_length)return std::strong_ordering::greater;return a.__buffer[0] * a.sign() <=> b;}std::strong_ordering operator <=>(const vinteger& a, const vinteger& b){if(auto r = a.__bit_length <=> b.__bit_length; r != std::strong_ordering::equal || (a.empty() && b.empty()))return r;for(int i = a.__value_length() - 1; i >= 0; --i)if(auto r = a.__buffer[i] <=> b.__buffer[i]; r != std::strong_ordering::equal)return r;return std::strong_ordering::equal;}}
namespace algae {extern std::int64_t __set_int_sign(const std::uint64_t x, int sign);inline vinteger::CUtype full_adder(vinteger::CUtype a, vinteger::CUtype b, bool& carry) {vinteger::CUtype c = a + b + carry;carry = (c < a) || (c < b) || (carry && c == 0);return c;}inline vinteger::CUtype full_subtractor(vinteger::CUtype a, vinteger::CUtype b, bool& retreat){vinteger::CUtype diff = a - b - retreat;retreat = a < b || (a == b && retreat);return diff;}inline vinteger::CUtype carry_handle(vinteger::CUtype x, bool& carry) {vinteger::CUtype c = x + carry;carry = c < x && carry;return c;}inline vinteger::CUtype retreat_handle(vinteger::CUtype x, bool& retreat){vinteger::CUtype diff = x - retreat;retreat = x == 0 && retreat;return diff;}struct adder_context {using __CUtype = vinteger::__CUtype;constexpr static std::size_t __CUtype_bit_length = vinteger::__CUtype_bit_length;vinteger* output = nullptr;const vinteger* max_vint = nullptr;const vinteger* min_vint = nullptr;std::size_t max_length = 0;std::size_t min_length = 0;int sign = 0;int mode = 0;int init_case_for_has_zero(const vinteger& a, const vinteger& b){if(a.empty() && b.empty())return 0;if(a.empty()){max_vint = &b, min_vint = &a;return -1;}max_vint = &a, min_vint = &b;    return 1;}void init_case_for_diff_bit_size(const vinteger& max_v, const vinteger& min_v){max_vint = &max_v, min_vint = &min_v;max_length = max_v.__value_length(), min_length = min_v.__value_length();}int init_case_for_same_space_size_with_miuns_mode(const vinteger& a, const vinteger& b){for(int i = a.__value_length() - 1; i >= 0; --i){if(a.__buffer[i] > b.__buffer[i]){max_vint = &a, min_vint = &b;max_length = min_length = i + 1;return 1;}else if(a.__buffer[i] < b.__buffer[i]){max_vint = &b, min_vint = &a;max_length = min_length = i + 1;return -1;}}return 0;}int init_final(const vinteger& a, const vinteger& b) {init_case_for_diff_bit_size(a, b);return 1;}void init_sign(int r_cmp, const vinteger& a, const vinteger& b, int plan){if(r_cmp == 0)return;if(mode == 0){if(plan > 0)sign = r_cmp > 0 ? a.sign() : b.sign();else sign = r_cmp > 0 ? a.sign() : -b.sign();return;}if(plan == 1){if(a.sign() > 0 && b.sign() < 0)sign = r_cmp;else if(a.sign() < 0 && b.sign() > 0)sign = -r_cmp;else sign = a.sign();return;}if(a.sign() > 0 && b.sign() > 0)sign = r_cmp;else if(a.sign() < 0 && b.sign() < 0)sign = -r_cmp;else sign = a.sign();}adder_context(const vinteger& a, const vinteger& b, vinteger& c, int plan):output(&c), mode(a.sign() * b.sign() * plan){int r_cmp = 0;if(mode == 0)r_cmp = init_case_for_has_zero(a, b);else if(a.value_bit_width() > b.value_bit_width())init_case_for_diff_bit_size(a, b), r_cmp = 1;else if(a.value_bit_width() < b.value_bit_width())init_case_for_diff_bit_size(b, a), r_cmp = -1;else if(mode == -1)r_cmp = init_case_for_same_space_size_with_miuns_mode(a, b);else r_cmp = init_final(a, b);init_sign(r_cmp, a, b, plan);run();}template<bool Mode>bool handle_overlapped_part(){bool carry_or_retreat = false;for(std::size_t i = 0; i < min_length; ++i) {if constexpr(Mode)output->__buffer[i] = full_adder(max_vint->__buffer[i], min_vint->__buffer[i], carry_or_retreat);else output->__buffer[i] = full_subtractor(max_vint->__buffer[i], min_vint->__buffer[i], carry_or_retreat);}return carry_or_retreat;}template<bool Mode>void handle_overflow_part(bool carry_or_retreat){std::size_t i = min_length;for(; i < max_length && carry_or_retreat; ++i){if constexpr(Mode)output->__buffer[i] = carry_handle(max_vint->__buffer[i], carry_or_retreat);else output->__buffer[i] = retreat_handle(max_vint->__buffer[i], carry_or_retreat);}if(carry_or_retreat){output->__buffer[max_length] = carry_or_retreat;output->__bit_length = __set_int_sign(max_vint->value_bit_width() + 1, sign);}else {std::memmove(output->__buffer + i, max_vint->__buffer + i, (max_length - i) * sizeof(__CUtype));if(mode < 0 && output->__buffer[max_length - 1] == 0){if(max_length > 1)output->__bit_length = __set_int_sign(std::bit_width(output->__buffer[max_length - 2]) + (max_length - 2) * __CUtype_bit_length, sign);else output->clear();}else output->__bit_length = __set_int_sign(std::bit_width(output->__buffer[max_length - 1]) + (max_length - 1) * __CUtype_bit_length, sign);}}void run(){if(sign == 0)output->clear();else if(mode == 0)*output = (sign == max_vint->sign() ? *max_vint : -(*max_vint));else {output->__try_reserve(mode > 0 ? max_length + 1 : max_length);bool carry_or_retreat = mode > 0 ? handle_overlapped_part<true>() : handle_overlapped_part<false>();if(mode > 0)handle_overflow_part<true>(carry_or_retreat);else handle_overflow_part<false>(carry_or_retreat);}}};vinteger vinteger::operator-() const {vinteger result(*this);result.__bit_length = -result.__bit_length;return result;}vinteger operator+(const vinteger& a, const vinteger& b) {vinteger c;adder_context(a, b, c, 1);return c;}vinteger operator-(const vinteger& a, const vinteger& b) {vinteger c;adder_context(a, b, c, -1);return c;}vinteger& vinteger::operator+=(const vinteger& b){adder_context(*this, b, *this, 1);return *this;}vinteger& vinteger::operator-=(const vinteger& b){adder_context(*this, b, *this, -1);return *this;}}
int main(){algae::vinteger a, b;std::cin >> a;std::cout << a;}