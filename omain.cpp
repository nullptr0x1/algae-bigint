#include <compare>
#include <cstdint>
#include <string>
#include <string_view>
#include <stdexcept>
#include <vector>
#include <utility>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
namespace algae{    class vinteger    {        class cast_standard        {            private:                static constexpr std::uint64_t init_overflow_bound()                {                    std::uint64_t l = 1;                    for(int i = 0; i < std::numeric_limits<std::uint64_t>::digits10; ++i)                        l *= 10;                    return l;                }            public:                static std::uint64_t overflow_bound;                static std::uint64_t half_overflow_bound;                std::vector<std::uint64_t> buffer;                std::size_t count = 64;                cast_standard()                    : buffer({std::numeric_limits<std::uint64_t>::max() % overflow_bound + 1,                            std::numeric_limits<std::uint64_t>::max() / overflow_bound})                {}                std::size_t length() const {                    return buffer.size();                }                std::size_t binary_length() const {                    return bit_width() / 64 + bool(bit_width() % 64);                }                std::size_t bit_width() const {                    return count + 1;                }                std::size_t power_of_2() const {                    return count;                }                void mul2()                {                    bool carry = false;                    for(auto& i : buffer)                    {                        bool carry_out = i >= half_overflow_bound;                        i = (carry_out ? (i - half_overflow_bound) : i) * 2 + carry;                        carry = carry_out;                    }                    if(carry)                        buffer.push_back(carry);                    ++count;                }                void div2()                {                    bool retreat = false;                    std::for_each(buffer.rbegin(), buffer.rend(), [&](std::uint64_t& i)                    {                        bool retreat_out = i & 1;                        i = retreat ? (i / 2) + half_overflow_bound : i / 2;                        retreat = retreat_out;                    });                    while(buffer.back() == 0)                        buffer.pop_back();                    --count;                }        };        class intermediate_state_integer        {            public:                std::uint64_t * buffer = nullptr;                std::uint32_t length = 0;                bool sign = false;            private:                static std::uint64_t * make_int64_memory(const std::size_t n)                {                    auto memory = new std::uint64_t[n];                    std::memset(memory, 0, n * sizeof(std::uint64_t));                    return memory;                }                inline bool bitget(const std::uint8_t * memory, std::size_t index) {                    return memory[index / 8] & (1 << (index % 8));                }                inline static std::uint64_t add_with_carry(std::uint64_t a, std::uint64_t b, bool& carry)                {                    a += carry;                    carry = a >= cast_standard::overflow_bound - b;                    return carry ? a - (cast_standard::overflow_bound - b) : a + b;                }            public:                intermediate_state_integer(const vinteger& source)                {                    buffer = make_int64_memory(std::max(std::size_t((source.__value_length() * 64 * 0.3010) / 8 + 1), std::size_t(2)));                    sign = source.__bit_length < 0;                    buffer[0] = source.__buffer[0] % cast_standard::overflow_bound;                    buffer[1] = source.__buffer[0] / cast_standard::overflow_bound;                    length = buffer[1] != 0 ? 2 : 1;                    for(cast_standard standard; standard.power_of_2() < source.value_bit_width(); standard.mul2())                    {                        bool carry = false;                        if(bitget((const std::uint8_t*)source.__buffer, standard.power_of_2()))                        {                            for(std::size_t i = 0; i < standard.length(); ++i)                                buffer[i] = add_with_carry(buffer[i], standard.buffer[i], carry);                            buffer[standard.length()] += carry;                            length = std::max((std::uint32_t)standard.length() + carry, length);                        }                    }                }                std::string convert_to_string()                {                    std::string result;                    result.reserve(length * 19 + sign);                    bool prefix_zeros = true;                    if(sign)                        result += '-';                    for(std::int64_t i = length - 1; i >= 0; --i)                    {                        for(std::uint64_t c = buffer[i], shift = cast_standard::overflow_bound / 10; shift >= 1; shift /= 10)                        {                            std::uint8_t r = c / shift;                            if(r == 0 && prefix_zeros)                                continue;                            prefix_zeros = false;                            result += r + '0';                            c %= shift;                        }                    }                return result;            }        };        using __computing_unit_type = std::uint_fast64_t;        using __CUtype = __computing_unit_type;        using __HCUtype = std::uint_fast32_t;        constexpr static std::size_t __CUtype_bit_length = sizeof(__CUtype) * 8;        constexpr static std::size_t __HCUtype_bit_length = sizeof(__HCUtype) * 8;        __CUtype * __buffer = nullptr;        std::int32_t __bit_length = 0;        std::uint32_t __capacity = 0;        void __change_capacity(std::uint32_t new_capacity, bool keep_value = false, bool initial = false)        {            if(new_capacity == 0)                return clear();            __CUtype * new_buffer = new __CUtype[new_capacity];            if(initial)                std::memset(new_buffer, 0, new_capacity * sizeof(__CUtype));            if(__buffer)            {                if(keep_value)                    std::memcpy(new_buffer, __buffer, __capacity * sizeof(__CUtype));                delete[] __buffer;            }            __buffer = new_buffer;            __capacity = new_capacity;        }        void __try_reserve(std::size_t unit_count)        {            if(unit_count > __capacity)                __change_capacity(unit_count, true);            else if(__value_length() == 0)                clear();        }        void __capacity_adaptive()        {            if(__capacity > __value_length())                __change_capacity(__value_length());        }        void __initialization_by_cinteger(std::int64_t x)        {            if(x == 0)                return;            __change_capacity(1);            __buffer[0] = (std::uintmax_t)std::abs(x);            __bit_length = std::bit_width(__buffer[0]) * (x < 0 ? -1 : 1);        }        void __initialization_by_cinteger(std::uint64_t x)        {            __change_capacity(1);            __buffer[0] = x;            __bit_length = std::bit_width(__buffer[0]);        }    public:        vinteger() = default;        template<std::integral T>        vinteger(T x)        {            if(std::is_signed_v<T>)                __initialization_by_cinteger((std::int64_t)x);            else                __initialization_by_cinteger((std::uint64_t)x);        }        template<std::floating_point T>        vinteger(T x) {            __initialization_by_cinteger((std::int64_t)std::floor(x));        }    private:        static int __legitimacy_testing(std::string_view source)        {            if(source.empty())                throw std::invalid_argument("source is empty");            int sign = source[0] == '-' ? -1 : 1;            if(!(source[0] == '-' || source[0] == '+' || std::isdigit(source[0])))                throw std::invalid_argument("source is not a valid integer");            for(size_t i = 1; i < source.size(); i++)                if(!std::isdigit(source[i]))                    throw std::invalid_argument("source is not a valid integer");            return sign;        }        static std::string_view __remove_prefix_zeros(std::string_view source)        {            for(std::size_t i = std::isdigit(source.front()) ? 0 : 1; i < source.size(); ++i)            {                if(source[i] != '0')                    return source.substr(i);            }            return "";        }    public:        vinteger(std::string_view source)        {            int sign = __legitimacy_testing(source);            std::string_view copy = __remove_prefix_zeros(source);            if(copy.empty())                return;            __HCUtype temporary = 0, shift = 1;            const static __HCUtype overflow_bound = std::pow(10, std::numeric_limits<__HCUtype>::digits10);            auto it = copy.begin();            for(;it != copy.end() && shift < overflow_bound; ++it)            {                if(shift != 1)                    temporary *= 10;                temporary += (*it - '0');                shift *= 10;            }            *this += temporary;            temporary = 0, shift = 1;            for(; it != copy.end(); ++it)            {                if(shift == overflow_bound)                {                    *this *= overflow_bound;                    *this += temporary;                    temporary = 0, shift = 1;                }                if(shift != 1)                    temporary *= 10;                temporary += (*it - '0');                shift *= 10;            }            *this *= shift;            *this += temporary;            __bit_length = __set_int_sign(__bit_length, sign);        }        vinteger(const vinteger& source) {            operator =(source);        }        vinteger(vinteger&& source) {            operator =(std::move(source));        }        template<std::unsigned_integral T>        vinteger& operator=(const T x)        {            if(x == 0)                clear();            else                __change_capacity(1), __bit_length = std::bit_width(x);            return *this;        }        template<std::signed_integral T>        vinteger& operator=(const T x)        {            this->operator=((std::make_unsigned<T>)std::abs(x));            __bit_length = __set_int_sign(__bit_length, x < 0 ? -1 : 1);            return *this;        }        vinteger& operator=(const vinteger& source)        {            if(this == &source)                return *this;            __change_capacity(source.__value_length());            std::memcpy(__buffer, source.__buffer, source.__value_length() * sizeof(__CUtype));            __bit_length = source.__bit_length;            return *this;        }        vinteger& operator=(vinteger&& source)        {            if(this == &source)                return *this;            if(__buffer)                delete[] __buffer;            __buffer = std::exchange(source.__buffer, nullptr);            __bit_length = std::exchange(source.__bit_length, 0);            __capacity = std::exchange(source.__capacity, 0);            return *this;        }        ~vinteger() {            clear();        }        inline bool empty() const {            return __bit_length == 0;        }        inline int sign() const        {            if(__bit_length == 0)                return 0;            return __bit_length > 0 ? 1 : -1;        }        inline std::size_t value_bit_width() const {            return std::abs(__bit_length);        }    private:        inline std::size_t __value_length() const {            return std::abs(__bit_length) / __CUtype_bit_length + bool(std::abs(__bit_length) % __CUtype_bit_length);        }        inline std::size_t __HCU_value_length() const {            return std::abs(__bit_length) / __HCUtype_bit_length + bool(std::abs(__bit_length) % __HCUtype_bit_length);        }    public:        void clear()        {            if(__buffer)                delete[] __buffer;            __buffer = nullptr;            __bit_length = 0;            __capacity = 0;        }        friend std::strong_ordering operator <=>(const vinteger&, const vinteger&);    private:        inline static int __int_sign(const std::int64_t x) {            if(x > 0)                return 1;            return x ? -1 : 0;        }        inline static int __int_sign(const std::uint64_t x) {            return x ? 1 : 0;        }        inline static std::int64_t __set_int_sign(const std::uint64_t x, int sign) {            return sign > 0 ? x : -((std::int64_t)x);        }        std::strong_ordering __compare_template(const vinteger& a, const std::int64_t b)        {            if(auto r = a.sign() <=> __int_sign(b) ; r != std::strong_ordering::equal || (a.empty() && b == 0))                return r;            if(a.value_bit_width() >= 63)                return std::strong_ordering::greater;            return __set_int_sign(a.__buffer[0], a.sign()) <=> b;        }        std::strong_ordering __compare_template(const vinteger& a, const std::uint64_t b)        {            if(auto r = a.sign() <=> __int_sign(b); r != std::strong_ordering::equal || (a.empty() && b == 0))                return r;            if(a.value_bit_width() >= __CUtype_bit_length)                return std::strong_ordering::greater;            return a.__buffer[0] * a.sign() <=> b;        }    public:        template<std::integral T>        friend std::strong_ordering operator <=>(const vinteger&, const T);        template<std::integral T>        friend std::strong_ordering operator <=>(const T, const vinteger&);        template<std::floating_point T>        friend std::strong_ordering operator <=>(const vinteger&, const T);        template<std::floating_point T>        friend std::strong_ordering operator <=>(const T, const vinteger&);        vinteger& operator <<=(const std::size_t shift)        {            if(shift == 0 || empty())                return *this;            const std::size_t length = __value_length();            const std::size_t shift_unit = shift / __CUtype_bit_length;            const std::size_t shift_bit = shift % __CUtype_bit_length;            std::uint64_t overflow = 0;            __bit_length += __set_int_sign(shift, sign());            __try_reserve(__value_length());            if(std::size_t i = 0; shift_bit)            {                while(__buffer[i] == 0)                {                    if((++i) >= length)                        break;                }                for(;i < length; ++i)                {                    const std::uint64_t temp = __buffer[i];                    __buffer[i] = overflow | (temp << shift_bit);                    overflow = temp >> (__CUtype_bit_length - shift_bit);                }            }            if(shift_unit)            {                std::memmove(__buffer + shift_unit, __buffer, length * sizeof(__CUtype));                std::memset(__buffer, 0, shift_unit * sizeof(__CUtype));            }            if(overflow)                __buffer[__value_length() - 1] = overflow;            return *this;        }        vinteger operator<<(const std::size_t shift) const        {            vinteger result(*this);            result <<= shift;            return result;        }        vinteger& operator >>=(const std::size_t shift)        {            if(shift == 0 || empty())                return *this;            const std::size_t length = __value_length();            const std::size_t shift_unit = shift / __CUtype_bit_length;            const std::size_t shift_bit = shift % __CUtype_bit_length;            if(std::uint64_t underflow = 0, stop = 0; shift_bit)            {                while(__buffer[stop] == 0)                {                    if((++stop) >= length)                        break;                }                for(int i = length - 1; i >= stop; --i)                {                    const std::uint64_t temp = __buffer[i];                    __buffer[i] = underflow | (temp >> shift_bit);                    underflow = temp << (__CUtype_bit_length - shift_bit);                }            }            if(shift_unit)                std::memmove(__buffer, __buffer + shift_unit, length * sizeof(__CUtype));            __bit_length -= __set_int_sign(shift, sign());            __try_reserve(__value_length());            return *this;        }        vinteger operator>>(const std::size_t shift) const        {            vinteger result(*this);            result >>= shift;            return result;        }    private:        struct adder_context        {            vinteger* output = nullptr;            const vinteger* max_vint = nullptr;            const vinteger* min_vint = nullptr;            std::size_t max_length = 0;            std::size_t min_length = 0;            int sign = 0;            int mode = 0;            int init_case_for_has_zero(const vinteger& a, const vinteger& b)            {                if(a.empty() && b.empty())                    return 0;                if(a.empty())                {                    max_vint = &b, min_vint = &a;                    return -1;                }                max_vint = &a, min_vint = &b;                return 1;            }            void init_case_for_diff_bit_size(const vinteger& max_v, const vinteger& min_v)            {                max_vint = &max_v, min_vint = &min_v;                max_length = max_v.__value_length(), min_length = min_v.__value_length();            }            int init_case_for_same_space_size_with_miuns_mode(const vinteger& a, const vinteger& b)            {                for(int i = a.__value_length() - 1; i >= 0; --i)                {                    if(a.__buffer[i] > b.__buffer[i])                    {                        max_vint = &a, min_vint = &b;                        max_length = min_length = i + 1;                        return 1;                    }                    else if(a.__buffer[i] < b.__buffer[i])                    {                        max_vint = &b, min_vint = &a;                        max_length = min_length = i + 1;                        return -1;                    }                }                return 0;            }            int init_final(const vinteger& a, const vinteger& b)            {                init_case_for_diff_bit_size(a, b);                return 1;            }            void init_sign(int r_cmp, const vinteger& a, const vinteger& b, int plan)            {                if(r_cmp == 0)                    return;                if(mode == 0)                {                    if(plan > 0)                        sign = r_cmp > 0 ? a.sign() : b.sign();                    else                        sign = r_cmp > 0 ? a.sign() : -b.sign();                    return;                }                if(plan == 1)                {                    if(a.sign() > 0 && b.sign() < 0)                        sign = r_cmp;                    else if(a.sign() < 0 && b.sign() > 0)                        sign = -r_cmp;                    else                        sign = a.sign();                    return;                }                if(a.sign() > 0 && b.sign() > 0)                    sign = r_cmp;                else if(a.sign() < 0 && b.sign() < 0)                    sign = -r_cmp;                else                    sign = a.sign();            }            adder_context(const vinteger& a, const vinteger& b, vinteger& c, int plan)                :output(&c), mode(a.sign() * b.sign() * plan)            {                int r_cmp = 0;                if(mode == 0)                    r_cmp = init_case_for_has_zero(a, b);                else if(a.value_bit_width() > b.value_bit_width())                    init_case_for_diff_bit_size(a, b), r_cmp = 1;                else if(a.value_bit_width() < b.value_bit_width())                    init_case_for_diff_bit_size(b, a), r_cmp = -1;                else if(mode == -1)                    r_cmp = init_case_for_same_space_size_with_miuns_mode(a, b);                else                    r_cmp = init_final(a, b);                init_sign(r_cmp, a, b, plan);                run();            }            inline static __CUtype full_adder(__CUtype a, __CUtype b, bool& carry)            {                __CUtype c = a + b + carry;                carry = (c < a) || (c < b) || (carry && c == 0);                return c;            }            inline static __CUtype full_subtractor(__CUtype a, __CUtype b, bool& retreat)            {                __CUtype diff = a - b - retreat;                retreat = a < b || (a == b && retreat);                return diff;            }            template<bool Mode>            bool handle_overlapped_part()            {                bool carry_or_retreat = false;                for(std::size_t i = 0; i < min_length; ++i)                {                    if constexpr(Mode)                        output->__buffer[i] = full_adder(max_vint->__buffer[i], min_vint->__buffer[i], carry_or_retreat);                    else                        output->__buffer[i] = full_subtractor(max_vint->__buffer[i], min_vint->__buffer[i], carry_or_retreat);                }                return carry_or_retreat;            }            inline static std::uint64_t carry_handle(__CUtype x, bool& carry)            {                __CUtype c = x + carry;                carry = c < x && carry;                return c;            }            inline static std::uint64_t retreat_handle(__CUtype x, bool& retreat)            {                __CUtype diff = x - retreat;                retreat = x == 0 && retreat;                return diff;            }            template<bool Mode>            void handle_overflow_part(bool carry_or_retreat)            {                std::size_t i = min_length;                for(; i < max_length && carry_or_retreat; ++i)                {                    if constexpr(Mode)                        output->__buffer[i] = carry_handle(max_vint->__buffer[i], carry_or_retreat);                    else                        output->__buffer[i] = retreat_handle(max_vint->__buffer[i], carry_or_retreat);                }                if(carry_or_retreat)                {                    output->__buffer[max_length] = carry_or_retreat;                    output->__bit_length = __set_int_sign(max_vint->value_bit_width() + 1, sign);                }                else                {                    std::memmove(output->__buffer + i, max_vint->__buffer + i, (max_length - i) * sizeof(__CUtype));                    if(mode < 0 && output->__buffer[max_length - 1] == 0)                    {                        if(max_length > 1)                            output->__bit_length = __set_int_sign(std::bit_width(output->__buffer[max_length - 2]) + (max_length - 2) * __CUtype_bit_length, sign);                        else                            output->clear();                    }                    else                        output->__bit_length = __set_int_sign(std::bit_width(output->__buffer[max_length - 1]) + (max_length - 1) * __CUtype_bit_length, sign);                }            }            void run()            {                if(sign == 0)                    output->clear();                else if(mode == 0)                    *output = (sign == max_vint->sign() ? *max_vint : -(*max_vint));                else                {                    output->__try_reserve(mode > 0 ? max_length + 1 : max_length);                    bool carry_or_retreat = mode > 0 ? handle_overlapped_part<true>() : handle_overlapped_part<false>();                    if(mode > 0)                        handle_overflow_part<true>(carry_or_retreat);                    else                        handle_overflow_part<false>(carry_or_retreat);                }            }        };    public:        vinteger operator-() const        {            vinteger result(*this);            result.__bit_length = -result.__bit_length;            return result;        }        friend vinteger operator+(const vinteger&, const vinteger&);        friend vinteger operator-(const vinteger&, const vinteger&);        template<std::integral T>        friend vinteger operator+(const vinteger&, const T);        template<std::integral T>        friend vinteger operator-(const vinteger&, const T);        template<std::integral T>        friend vinteger operator+(const T, const vinteger&);        template<std::integral T>        friend vinteger operator-(const T, const vinteger&);        vinteger& operator+=(const vinteger& b)        {            vinteger::adder_context(*this, b, *this, 1);            return *this;        }        vinteger& operator-=(const vinteger& b)        {            vinteger::adder_context(*this, b, *this, -1);            return *this;        }        template<std::integral T>        vinteger& operator+=(const T x) {            return operator+=(vinteger(x));        }        template<std::integral T>        vinteger& operator-=(const T x) {            return operator-=(vinteger(x));        }        template<std::floating_point T>        vinteger& operator+=(const T x) {            return operator+=(vinteger(x));        }        template<std::floating_point T>        vinteger& operator-=(const T x) {            return operator-=(vinteger(x));        }    private:        struct multiplier_context        {            const vinteger * vint_max = nullptr;            const vinteger * vint_min = nullptr;            vinteger * output = nullptr;            int sign = 0;            bool pretreatment(const vinteger& x, const vinteger& y, vinteger& z)            {                if(x.empty() || y.empty())                    z.clear();                else if(x.value_bit_width() > 32 || y.value_bit_width() > 32)                    return false;                else if(x.value_bit_width() == 1)                    z = x.sign() == y.sign() ? y : -y;                else if(y.value_bit_width() == 1)                    z = x.sign() == y.sign() ? x : -x;                else                {                    z.__change_capacity(1);                    z.__buffer[0] = x.__buffer[0] * y.__buffer[0];                    z.__bit_length = __set_int_sign(std::bit_width(z.__buffer[0]), x.sign() * y.sign());                }                return true;            }            multiplier_context(const vinteger& x, const vinteger& y, vinteger& z, bool test = false)            {                if(pretreatment(x, y, z))                   return;                sign = x.sign() * y.sign();                output = &z;                if (x >= y)                    vint_max = &x, vint_min = &y;                else                    vint_max = &y, vint_min = &x;                if(vint_min->value_bit_width() <= 32 && test)                    unit_multiplication();                else                    alpha_multiplication();            }            inline static __HCUtype multiplication_with_overflow(const __HCUtype a, const __HCUtype b, __HCUtype& overflow)            {                const __CUtype r = (__CUtype)a * (__CUtype)b + (__CUtype)overflow;                overflow = r >> 32;                return r;            }            void unit_multiplication()            {                output->__change_capacity(vint_max->__value_length() + 1, false, true);                this->output->__buffer[vint_max->__value_length() - 1] = 0;                this->output->__buffer[vint_max->__value_length()] = 0;                __HCUtype* vint_out = (__HCUtype*)this->output->__buffer;                const __HCUtype* vint_max = (__HCUtype*)this->vint_max->__buffer;                const __HCUtype  vint_min = this->vint_min->__buffer[0];                const std::size_t length =  this->vint_max->__HCU_value_length();                __HCUtype overflow = 0;                for(std::size_t i = 0; i < length; ++i)                    vint_out[i] = multiplication_with_overflow(vint_max[i], vint_min, overflow);                if(overflow)                {                    vint_out[length] = overflow;                    output->__bit_length = __set_int_sign(std::bit_width(overflow) + length * __HCUtype_bit_length, sign);                }                else                    output->__bit_length = __set_int_sign(std::bit_width(vint_out[length - 1]) + (length - 1) * __HCUtype_bit_length, sign);            }            void alpha_multiplication()            {                int c = std::bit_width(vint_min->__buffer[0]);                for(int i = vint_min->value_bit_width() - 1; i >= 0; --i)                {                    if(!(vint_min->__buffer[i / __CUtype_bit_length] & (1ull << __CUtype(i % __CUtype_bit_length))))                        continue;                    *output += (*vint_max << i);                }                output->__bit_length = __set_int_sign(output->__bit_length, sign);            }        };    public:        friend vinteger operator*(const vinteger&, const vinteger&);        template<std::integral T>        friend vinteger operator*(const vinteger&, const T);        template<std::integral T>        friend vinteger operator*(const T, const vinteger&);        vinteger& operator*=(const vinteger& other)        {            vinteger c;            vinteger::multiplier_context(*this, other, c, true);            *this = std::move(c);            return *this;        }        template<std::integral T>        vinteger operator*=(const T x) {            return (*this *= vinteger(x));        }        std::string to_string() const        {            if(empty())                return "0";            return vinteger::intermediate_state_integer(*this).convert_to_string();        }        operator std::string() const {            return to_string();        }    };    std::strong_ordering operator <=>(const vinteger& a, const vinteger& b)    {        if(auto r = a.__bit_length <=> b.__bit_length; r != std::strong_ordering::equal || (a.empty() && b.empty()))            return r;        for(int i = a.__value_length() - 1; i >= 0; --i)            if(auto r = a.__buffer[i] <=> b.__buffer[i]; r != std::strong_ordering::equal)                return r;        return std::strong_ordering::equal;    }    template<std::integral T>    std::strong_ordering operator <=>(const vinteger& a, const T b) {        return vinteger::__compare_template(a, b);    }    template<std::integral T>    std::strong_ordering operator <=>(const T b, const vinteger& a)    {        auto r = vinteger::__compare_template(a, b);        if(r == std::strong_ordering::less)            return std::strong_ordering::greater;        if(r == std::strong_ordering::greater)            return std::strong_ordering::less;        return std::strong_ordering::equal;    }    template<std::floating_point T>    std::strong_ordering operator <=>(const vinteger& a, const T b) {        return a <=> (std::int64_t)std::ceil(b);    }    template<std::floating_point T>    std::strong_ordering operator <=>(const T a, const vinteger& b) {        return (std::int64_t)std::ceil(a) <=> b;    }    vinteger operator+(const vinteger& a, const vinteger& b)    {        vinteger c;        vinteger::adder_context(a, b, c, 1);        return c;    }    vinteger operator-(const vinteger& a, const vinteger& b)    {        vinteger c;        vinteger::adder_context(a, b, c, -1);        return c;    }    template<std::integral T>    vinteger operator+(const vinteger& a, const T b) {        return a + vinteger(b);    }    template<std::integral T>    vinteger operator-(const vinteger& a, const T b) {        return a - vinteger(b);    }    template<std::integral T>    vinteger operator+(const T a, const vinteger& b) {        return vinteger(a) + b;    }    template<std::integral T>    vinteger operator-(const T a, const vinteger& b) {        return vinteger(a) - b;    }    vinteger operator*(const vinteger& a, const vinteger& b)    {        vinteger c;        vinteger::multiplier_context(a, b, c, true);        return c;    }    template<std::integral T>    vinteger operator*(const vinteger& a, const T b) {        return a * vinteger(b);    }    template<std::integral T>    vinteger operator*(const T a, const vinteger& b) {        return vinteger(a) * b;    }    std::istream& operator >> (std::istream& in, vinteger& arg)    {        std::string s;        in >> s;        arg = vinteger(s);        return in;    }    std::ostream& operator << (std::ostream& out, const vinteger& arg)    {        out << arg.to_string();        return out;    }    namespace vinteger_literals    {        vinteger operator ""_vi(const char* x) {            return vinteger(x);        }    }    std::uint64_t vinteger::cast_standard::overflow_bound = vinteger::cast_standard::init_overflow_bound();    std::uint64_t vinteger::cast_standard::half_overflow_bound = vinteger::cast_standard::overflow_bound / 2;}
#include <ctime>
void test_0(){    {        std::uint64_t a = std::time(nullptr), b = std::time(nullptr), c = 0;        bool carry = 0;        std::clock_t stime = std::clock();        for(std::uint64_t i = 0; i < 0xFFFFFFFF; ++i)        {            std::uint64_t t = a + b + carry;            carry = (t < a) || (t < b) || (carry && t == 0);            c = t;        }        std::cout << (std::clock() - stime) / (double)(CLOCKS_PER_SEC) << std::endl;    }    {        std::clock_t stime = std::clock();        std::uint32_t a = std::time(nullptr), b = std::time(nullptr), c = 0;        bool carry = 0;        for(std::uint64_t i = 0, l = 0xFFFFFFFFull * 2; i < l; ++i)        {            std::uint64_t t = a + b + carry;            carry = t & 0xFFFFFFFF00000000;            c = t;        }        std::cout << (std::clock() - stime) / (double)(CLOCKS_PER_SEC) << std::endl;    }}int main(){    algae::vinteger a, b;    std::cin >> a >> b;    std::cout << a * b;}